#include <cflw图形_d3d着色器.h>
#include "图形.h"
#include "常量.h"
namespace 着色器 = cflw::图形::d3d着色器;
void C图形::f初始化(HWND a窗口) {
	m三维.f初始化(a窗口);
	auto &v渲染控制 = m三维.fg渲染控制();
	auto &v渲染状态 = m三维.fg渲染状态();
	auto &v缓冲工厂 = m三维.fg缓冲工厂();
	//空间图形管线
	三维::C顶点格式 v顶点格式;
	v顶点格式.f添加(三维::C顶点格式::e位置, 3);
	v顶点格式.f添加(三维::C顶点格式::e颜色, 4);
	着色器::C着色器工厂 v着色器工厂;
	v着色器工厂.f初始化();
	着色器::tp着色器 v空间v, v空间p;
	v着色器工厂.f编译顶点着色器(v空间v, L"着色器.hlsl", "vs");
	v着色器工厂.f编译像素着色器(v空间p, L"着色器.hlsl", "ps");
	三维::S图形管线参数 v空间;
	v空间.fs顶点着色器(着色器::fc跨度(v空间v));
	v空间.fs像素着色器(着色器::fc跨度(v空间p));
	v空间.fs输入布局(v顶点格式);
	v空间.fs光栅化(v渲染状态.m光栅化.m显示隐藏面.Get());
	v空间.fs混合(v渲染状态.m混合.m开启透明.Get());
	三维::S深度模板参数 v空间深度模板;
	v空间深度模板.fs深度部分(v渲染状态.m深度模板参数.m正常深度r);
	v空间深度模板.fs模板部分(v渲染状态.m深度模板参数.m模板比较);
	v空间.fs深度模板(v空间深度模板);
	m三维.f创建图形管线(m空间, v空间);
	//遮罩图形管线
	v顶点格式.f清空();
	v顶点格式.f添加(三维::C顶点格式::e位置, 2);
	着色器::tp着色器 v遮罩v, v遮罩p;
	v着色器工厂.f编译顶点着色器(v遮罩v, L"遮罩.hlsl", "vs_mask");
	v着色器工厂.f编译像素着色器(v遮罩p, L"遮罩.hlsl", "ps_mask");
	三维::S图形管线参数 v遮罩;
	v遮罩.fs顶点着色器(着色器::fc跨度(v遮罩v));
	v遮罩.fs像素着色器(着色器::fc跨度(v遮罩p));
	v遮罩.fs输入布局(v顶点格式);
	v遮罩.fs光栅化(v渲染状态.m光栅化.m显示隐藏面.Get());
	v遮罩.fs混合(v渲染状态.m混合.m开启透明.Get());
	v遮罩.fs深度模板(v渲染状态.m深度模板.m模板标记.Get());
	m三维.f创建图形管线(m遮罩, v遮罩);
	//顶点
	struct S顶点 {
		数学::S向量3 m坐标;
		数学::S颜色 m颜色;
	};
	S顶点 va顶点[c三角形顶点数] = {};
	for (int i = 0; i != c三角形数; ++i) {
		const int v基数 = i * 3;
		const 数学::S颜色 v颜色 = 数学::S颜色::fc彩虹(i);
		const float v深度 = ((float)i - (float)(c三角形数 - 1) / 2) / 2;
		va顶点[v基数] = {数学::S向量3(0, 1, v深度), v颜色};
		va顶点[v基数+1] = {数学::S向量3(1, -1, v深度), v颜色};
		va顶点[v基数+2] = {数学::S向量3(-1, -1, v深度), v颜色};
	}
	v缓冲工厂.f创建缓冲(m三角形顶点, va顶点, sizeof(va顶点), 三维::E缓冲::e顶点);
	//常量
	m总矩阵.m世界 = m世界.ft矩阵4();
	数学::S相机 v相机;
	v相机.m坐标 = {0, 0, 3};
	v相机.m目标 = {0, 0, 0};
	v相机.m上方 = {0, 1, 0};
	m总矩阵.m视图 = v相机.ft矩阵4r();
	数学::S透视投影 v投影 = {c基础宽度, c基础高度};
	m总矩阵.m投影 = v投影.ft矩阵4r();
	v缓冲工厂.f创建缓冲(m空间常量, &m总矩阵, sizeof(m总矩阵), 三维::E缓冲::e常量);
	//遮罩
	数学::S向量2 va遮罩顶点[c圆顶点数] = {数学::S向量2::c零};
	for (int i = 0; i != c圆边数; ++i) {
		const float v百分比 = (float)i / (float)c圆边数;
		va遮罩顶点[i + 1] = 数学::S向量2::fc方向r(c圆半径, v百分比 * 数学::c二π<float>);
	}
	v缓冲工厂.f创建缓冲(m遮罩顶点, va遮罩顶点, sizeof(va遮罩顶点), 三维::E缓冲::e顶点);
	uint16_t va遮罩索引[c圆索引数];
	for (int i = 0; i != c圆边数; ++i) {
		const int v基数 = i * 3;
		va遮罩索引[v基数] = 0;
		va遮罩索引[v基数+1] = i + 1;
		va遮罩索引[v基数+2] = i + 2;
	}
	va遮罩索引[c圆索引数 -1] = 1;
	v缓冲工厂.f创建缓冲(m遮罩索引, va遮罩索引, sizeof(va遮罩索引), 三维::E缓冲::e索引);
	const 数学::S向量2 v基础范围 = {c基础范围x, c基础范围y};
	v缓冲工厂.f创建缓冲(m平面常量, &v基础范围, sizeof(v基础范围), 三维::E缓冲::e常量);
	//其它状态
	v渲染控制.fs图元拓扑(三维::E图元拓扑::e列表三角形);
}
void C图形::f销毁() {
	m三维.f销毁();
}
void C图形::f计算() {
	m世界.m旋转.x += c帧秒 * 0.9f;
	m世界.m旋转.y += c帧秒 * 0.5f;
	m世界.m旋转.z += c帧秒 * 0.2f;
}
void C图形::f更新() {
	auto &v渲染控制 = m三维.fg渲染控制();
	m总矩阵.m世界 = m世界.ft矩阵4();
	v渲染控制.f更新资源(m空间常量.Get(), &m总矩阵);
}
void C图形::f显示() {
	auto &v渲染控制 = m三维.fg渲染控制();
	v渲染控制.f清屏();
	//遮罩
	v渲染控制.fs模板参考值(1);
	v渲染控制.fs图形管线(*m遮罩);
	v渲染控制.fs顶点缓冲(m遮罩顶点.Get(), sizeof(float) * 2);
	v渲染控制.fs索引缓冲(m遮罩索引.Get());
	v渲染控制.fs常量缓冲(0, m平面常量.Get());
	v渲染控制.f绘制索引(c圆索引数);
	//立方体
	v渲染控制.fs图形管线(*m空间);
	v渲染控制.fs顶点缓冲(m三角形顶点.Get(), sizeof(float) * 7);
	v渲染控制.fs常量缓冲(0, m空间常量.Get());
	v渲染控制.f绘制(c三角形顶点数);
	v渲染控制.f显示();
}